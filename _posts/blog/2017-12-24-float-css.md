---
layout:     post
title:      关于浮动的初步理解
category: blog
description: 初学浮动的感悟
---

<h2>一、浮动的特点：</h2>
  
  1.块元素在一行显示
  
  2.内联元素支持宽高
  
  3.默认使用内容撑开宽高
  
  （以上三点与inline-block相同，即和内联元素一样没有上下外边距，只有左右外边距并且不会合并，不支持margin：0 auto；）
  
  4.脱离文档流，以它的父级为参考左右定位（父级里面左边的位置，或父级右边），上边如果有兄弟元素就排到兄弟元素下面，如果没有就参考父级，即变成父级里面左上角或右上角的位置。
  
  5.提升层级半级即z-index加0.5

<h2>二、为什么要清除浮动？</h2>
   
   很多事没有为什么，但电脑程序就不会。没有必要的操作一定会省略，没有省略的话必然有充分的理由。
   
   我们知道元素浮动改变了元素本来的特性。这当然是我们想要的，但特性改变肯定也会带来麻烦，所谓的清除浮动就是清除元素浮动后产生的“负作用”。实际上我们在使用浮动时，大部分情况都是为了利用它的前三个特性，所以要消除后两个特性产生的影响。
   
   后两个特性会产生什么影响呢？a元素浮动脱离了文档流，并且层级比其父级元素b高0.5级，所以它们已经不在同一平面上显示。即在父级元素b的内容区里面原本属于a的空间消失了，那么b的内容区自然也会减少原来a所占的高度。块元素的高度默认是其内容区撑起来的，所以b的高度受其内容区的影响变小了。而在已经布局好的页面中，如果某个元素的高度发生了变化，那就一定会产生连锁反应，最终打乱整个页面的布局。所以在考虑浮动的时候，一定要同时考虑清除浮动（的负面影响）。

<h2>三、如何清除浮动？</h2>
   
   <h3>清除浮动（的负面影响）的方法有很多：</h3> 
   
   1.为高度受影响的元素即父级元素b设置一个固定的高度，那么它的内容区就不会因为a的离去而变化。既然内容区不变，那么b的高度就不变。
   
   2.为高度受影响的元素即b加上浮动，那么b和a处于同一平面，一切照旧所以b的高度就不会变化。但这么做会影响b的父级，所以没有从根本上解决问题。
   
   3.为b加上display：inline-block，效果与2相同 虽然这么做不会影响到b的父级但b本身margin：0 auto；失效。我们浮动只想改变a而已，b布局上的任何东西都应该不变。这个方法只是2的改进版，仍不符合我们的要求。
   
   以上三种方法只有1从根本上解决了浮动的问题，但是它不是一个通用的无脑的方法，你要考虑具体的高度问题。实际上页面的布局里面浮动是最常用的手段，所以经常要清各种浮动，使用1就没有很好的效率了。在css中，针对清浮动问题有专门的属性clear：left/right/none/both/inherit(继承)；顾名思义，清除这个元素左右无全部和继承的浮动元素。清除的意思是不允许出现，只能在下面或上面。这个样式本身不能解决b高度变化的问题，但配合一些其他东西就可以实现解决b高度的变化。如下：
   
   4.在b内a的下面添加空标签c，并给这个标签加样式clear：both；这个方法通吃，可以在任何情况下使用。缺点是不兼容ie6。
   
   5.在b内添加`<br clear="all"/>`这也可以，效果同上。但不推荐，因为布局是css的事情，html不要参合，并且清得多会很乱。
   
   <h3>先解释下4的原理吧：</h3>
   
   首先要从浮动元素的脱离文档流说起，假设在b中有a和c两个元素：a浮动后的位置实际上取决于在父元素b中它上边的兄弟元素c：
   
   `1.如果c不在a上边，即a是b中第一个元素，c是第二个元素。那a浮动后的位置是以父元素b为参考的（a在b里面的左上角或右上角），c顶上去占了a原来的位置。a实际上“覆盖”了c的区域，如果a比c小，那么c中的字符串会从a下方跑出来沿着边缘分布。如果a比c大，那c会被a完全遮住。需要注意c并没有消失，只是被a遮住了而已。因为a脱离文档流不在b的内容区了，所以b的高度缩小为仅被c撑起来的程度。`
   
   `2.如果c在a上边，即c是第一个，a是第二个。那么a浮动后会找到它上边的c，并紧挨着c分布。（a在c外面的左下角或右下角）b的高度仍然缩小为只被c撑起来的程度。`
   
   明白以上两点后再来分析方案4
   
   现在a下面有一个空的c，a是第一个，c是第二个。那a浮动后c会顶上去，a在c的正上方遮盖c。但c的宽度为0，所以a肯定在c的左边或右边，然而c加上clear：both；不允许它的左右两边存在浮动元素，所以a只能被挤到c上边（为什么不是下边，因为a是第一个，它在b里面的左上角或右上角）。然而c的高度也为0，c相当于是附着在b的上边框。所以在b里面，c上面空间为0，b的高度即为c的高度也为0。但a只能在c上面的空间，所以c无奈之下被迫挤下来，附着到a的下边框。此时b的上边框和a的上边框紧挨，b的下边框则和a的下边框紧挨。（c高度为0，也没加边框 没有实体）那么b的高度相当于被a撑了起来。（注意c必须为块级元素，否则c不会卡在a的下边框而是绕着a的边缘分布，可能在右上角或左上角吧。那就搞笑了，前功尽弃。）虽然a浮动了，但b的高度仍然没变。这样我们的目的就达到了。
   
   至于5呢是一样的原理。看得出来4和5都是接近完美地方案，但是也都因为一些小瑕疵而不能用。尤其是4，所以在4的基础上完美解决ie6的兼容性后就诞生了方案6:
   
   6.利用伪类::after，比如`.b::after{content:"";display:block;clear:both;}`伪类::after和content必须成对出现，当然这里为了模拟4的条件，也必须出现。空，块级元素，清除浮动都有了，4的方案完全模拟了。但兼容性问题不解决还是和4一样没用，所以还要加上`.b{zoom:1;}`解决ie678兼容性问题。
   
   第6个方法已经无懈可击了，但实际上还有一种方法只需要一行代码搞定，但也是有些小瑕疵：
   
   7.给b加上overflow：hidden，那也和上面效果一样，但overflow：hidden因为会把超出的部分隐藏，所以功能不单单是清浮动，换句话说就是不够专业。除非遇到既想清浮动又想把超出的部分隐藏的情况下，用起来才行。
   
  总结:暂时来看用6似乎是最好的方法。